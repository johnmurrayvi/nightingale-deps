--- a/gfx/cairo/cairo/src/cairo-d2d-surface.cpp	
+++ a/gfx/cairo/cairo/src/cairo-d2d-surface.cpp	
@@ -2590,17 +2590,17 @@ _cairo_d2d_acquire_source_image(void                    *abstract_surface,
 				       data.RowPitch,
 				       size.height);
 
     }
     /* these are the only surface statuses we expect */
     assert(cairo_surface_status(image_out) == CAIRO_STATUS_SUCCESS ||
 	   cairo_surface_status(image_out) == CAIRO_STATUS_NO_MEMORY);
 
-    *image_extra = softTexture.forget();
+    *image_extra = softTexture.forget().drop();
     *image_out_ret = (cairo_image_surface_t*)image_out;
 
     return cairo_surface_status(image_out);
 }
 
 static void
 _cairo_d2d_release_source_image(void                   *abstract_surface,
 				cairo_image_surface_t  *image,
@@ -2663,17 +2663,17 @@ _cairo_d2d_acquire_dest_image(void                    *abstract_surface,
 	return _cairo_error(CAIRO_STATUS_NO_DEVICE);
     }
     *image_out = 
 	(cairo_image_surface_t*)cairo_image_surface_create_for_data((unsigned char*)data.pData,
 										  _cairo_format_from_content(d2dsurf->base.content),
 										  size.width,
 										  size.height,
 										  data.RowPitch);
-    *image_extra = softTexture.forget();
+    *image_extra = softTexture.forget().drop();
 
     return CAIRO_STATUS_SUCCESS;
 }
 
 static void
 _cairo_d2d_release_dest_image(void                    *abstract_surface,
 			      cairo_rectangle_int_t   *interest_rect,
 			      cairo_image_surface_t   *image,
--- gfx/cairo/cairo/src/cairo-win32-refptr.h  2014-04-14 10:18:32.333538275 -0400
+++ gfx/cairo/cairo/src/cairo-win32-refptr.h  2014-04-13 21:06:36.091361469 -0400
@@ -31,61 +31,75 @@
  * The Initial Developer of the Original Code is the Mozilla Foundation
  *
  * Contributor(s):
- * Bas Schouten <bschouten@mozilla.com>
+ *  Bas Schouten <bschouten@mozilla.com>
  */
 #ifndef CAIRO_WIN32_REFPTR_H
 #define CAIRO_WIN32_REFPTR_H
 
-template<class T>
+template<typename T> class TemporaryRef;
+
+/**
+ * RefPtr points to a refcounted thing that has AddRef and Release
+ * methods to increase/decrease the refcount, respectively.  After a
+ * RefPtr<T> is assigned a T*, the T* can be used through the RefPtr
+ * as if it were a T*.
+ *
+ * A RefPtr can forget its underlying T*, which results in the T*
+ * being wrapped in a temporary object until the T* is either
+ * re-adopted from or released by the temporary.
+ */
+template<typename T>
 class RefPtr
 {
+    // To allow them to use unref()
+    friend class TemporaryRef<T>;
+
+    struct dontRef {};
+
 public:
-    RefPtr() : mPtr(NULL)
-    { }
+    RefPtr() : ptr(0) { }
+    RefPtr(const RefPtr& o) : ptr(ref(o.ptr)) {}
+    RefPtr(const TemporaryRef<T>& o) : ptr(o.drop()) {}
+    RefPtr(T* t) : ptr(ref(t)) {}
 
-    RefPtr(T *aPtr) : mPtr(aPtr)
-    {
- if (mPtr) {
-     mPtr->AddRef();
- }
-    }
+    template<typename U>
+    RefPtr(const RefPtr<U>& o) : ptr(ref(o.get())) {}
 
-    RefPtr(const RefPtr<T> &aRefPtr)
-    {
- mPtr = aRefPtr.mPtr;
- if (mPtr) {
-     mPtr->AddRef();
- }
-    }
+    ~RefPtr() { unref(ptr); }
 
-    template <class newType>
-    explicit RefPtr(const RefPtr<newType> &aRefPtr)
-    {
- mPtr = aRefPtr.get();
- if (mPtr) {
-     mPtr->AddRef();
- }
+    RefPtr& operator=(const RefPtr& o) {
+        assign(ref(o.ptr));
+        return *this;
     }
 
-    ~RefPtr()
-    {
- if (mPtr) {
-     mPtr->Release();
- }
+    RefPtr& operator=(const TemporaryRef<T>& o) {
+        assign(o.drop());
+        return *this;
+    }
+    RefPtr& operator=(T* t) {
+        assign(ref(t));
+        return *this;
     }
 
-    RefPtr<T> &operator =(const RefPtr<T> aPtr)
-    {
- assignPtr(aPtr.mPtr);
- return *this;
+    template<typename U>
+    RefPtr& operator=(const RefPtr<U>& o) {
+        assign(ref(o.get()));
+        return *this;
     }
-    
-    RefPtr<T> &operator =(T* aPtr)
-    {
- assignPtr(aPtr);
- return *this;
+
+    TemporaryRef<T> forget() {
+        T* tmp = ptr;
+        ptr = 0;
+        return TemporaryRef<T>(tmp, dontRef());
     }
 
+    T* get() const { return ptr; }
+    operator T*() const { return ptr; }
+    T* operator->() const { return ptr; }
+    T& operator*() const { return *ptr; }
+    template<typename U>
+    operator TemporaryRef<U>() { return TemporaryRef<U>(ptr); }
+
     /** 
      * WARNING for ease of use, passing a reference will release/clear out ptr!
      * We null out the ptr before returning its address so people passing byref
@@ -95,67 +109,71 @@
      */
     T** operator&()
     {
- if (mPtr) {
-     mPtr->Release();
-     mPtr = NULL;
- }
- return &mPtr;
+       if (ptr) {
+           ptr->Release();
+           ptr = NULL;
+       }
+       return &ptr;
     }
 
-    T* operator->()
-    {
- return mPtr;
+private:
+    void assign(T* t) {
+        unref(ptr);
+        ptr = t;
     }
 
-    T* operator->() const
-    {
- return mPtr;
-    }
+    T* ptr;
 
-    operator bool()
-    {
- return (mPtr ? true : false);
+    static inline T* ref(T* t) {
+        if (t) {
+            t->AddRef();
+        }
+        return t;
     }
 
-    operator T*()
-    {
- return mPtr;
+    static inline void unref(T* t) {
+        if (t) {
+            t->Release();
+        }
     }
+};
 
-    template <class newType>
-    operator RefPtr<newType>()
-    {
- RefPtr<newType> newPtr;
- newPtr = mPtr;
- return newPtr;
-    }
+/**
+ * TemporaryRef<T> represents an object that holds a temporary
+ * reference to a T.  TemporaryRef objects can't be manually ref'd or
+ * unref'd (being temporaries, not lvalues), so can only relinquish
+ * references to other objects, or unref on destruction.
+ */
+template<typename T>
+class TemporaryRef
+{
+    // To allow it to construct TemporaryRef from a bare T*
+    friend class RefPtr<T>;
 
-    T* get() const
-    {
- return mPtr;
-    }
+    typedef typename RefPtr<T>::dontRef dontRef;
 
-    T* forget()
-    {
- T* ptr = mPtr;
- mPtr = NULL;
- return ptr;
+public:
+    TemporaryRef(T* t) : ptr(RefPtr<T>::ref(t)) {}
+    TemporaryRef(const TemporaryRef& o) : ptr(o.drop()) {}
+
+    template<typename U>
+    TemporaryRef(const TemporaryRef<U>& o) : ptr(o.drop()) {}
+
+    ~TemporaryRef() { RefPtr<T>::unref(ptr); }
+
+    T* drop() const {
+        T* tmp = ptr;
+        ptr = 0;
+        return tmp;
     }
 
 private:
-    void assignPtr(T* aPtr)
-    {
- T *oldPtr = mPtr;
- mPtr = aPtr;
- if (mPtr) {
-     mPtr->AddRef();
- }
- if (oldPtr) {
-     oldPtr->Release();
- }
-    }
+    TemporaryRef(T* t, const dontRef&) : ptr(t) {}
+
+    mutable T* ptr;
 
-    T *mPtr;
+    TemporaryRef();
+    TemporaryRef& operator=(const TemporaryRef&);
 };
 
 #endif
