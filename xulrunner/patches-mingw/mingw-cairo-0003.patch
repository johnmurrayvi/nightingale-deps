--- gfx/cairo/cairo/src/cairo-win32-refptr.h	2014-04-13 20:49:16.904310512 -0400
+++ gfx/cairo/cairo/src/cairo-win32-refptr.h	2014-04-13 21:06:36.091361469 -0400
@@ -36,57 +36,70 @@
 #ifndef CAIRO_WIN32_REFPTR_H
 #define CAIRO_WIN32_REFPTR_H
 
-template<class T>
+template<typename T> class TemporaryRef;
+
+/**
+ * RefPtr points to a refcounted thing that has AddRef and Release
+ * methods to increase/decrease the refcount, respectively.  After a
+ * RefPtr<T> is assigned a T*, the T* can be used through the RefPtr
+ * as if it were a T*.
+ *
+ * A RefPtr can forget its underlying T*, which results in the T*
+ * being wrapped in a temporary object until the T* is either
+ * re-adopted from or released by the temporary.
+ */
+template<typename T>
 class RefPtr
 {
+    // To allow them to use unref()
+    friend class TemporaryRef<T>;
+
+    struct dontRef {};
+
 public:
-    RefPtr() : mPtr(NULL)
-    { }
+    RefPtr() : ptr(0) { }
+    RefPtr(const RefPtr& o) : ptr(ref(o.ptr)) {}
+    RefPtr(const TemporaryRef<T>& o) : ptr(o.drop()) {}
+    RefPtr(T* t) : ptr(ref(t)) {}
 
-    RefPtr(T *aPtr) : mPtr(aPtr)
-    {
-    if (mPtr) {
-        mPtr->AddRef();
-    }
-    }
+    template<typename U>
+    RefPtr(const RefPtr<U>& o) : ptr(ref(o.get())) {}
 
-    RefPtr(const RefPtr<T> &aRefPtr)
-    {
-    mPtr = aRefPtr.mPtr;
-    if (mPtr) {
-        mPtr->AddRef();
-    }
-    }
+    ~RefPtr() { unref(ptr); }
 
-    template <class newType>
-    explicit RefPtr(const RefPtr<newType> &aRefPtr)
-    {
-    mPtr = aRefPtr.get();
-    if (mPtr) {
-        mPtr->AddRef();
-    }
+    RefPtr& operator=(const RefPtr& o) {
+        assign(ref(o.ptr));
+        return *this;
     }
 
-    ~RefPtr()
-    {
-    if (mPtr) {
-        mPtr->Release();
+    RefPtr& operator=(const TemporaryRef<T>& o) {
+        assign(o.drop());
+        return *this;
     }
+    RefPtr& operator=(T* t) {
+        assign(ref(t));
+        return *this;
     }
 
     template<typename U>
-    RefPtr<T> &operator =(const RefPtr<U> aPtr)
-    {
-    assignPtr(aPtr);
-    return *this;
+    RefPtr& operator=(const RefPtr<U>& o) {
+        assign(ref(o.get()));
+        return *this;
     }
-    
-    RefPtr<T> &operator =(T* aPtr)
-    {
-    assignPtr(aPtr);
-    return *this;
+
+    TemporaryRef<T> forget() {
+        T* tmp = ptr;
+        ptr = 0;
+        return TemporaryRef<T>(tmp, dontRef());
     }
 
+    T* get() const { return ptr; }
+    operator T*() const { return ptr; }
+    T* operator->() const { return ptr; }
+    T& operator*() const { return *ptr; }
+    template<typename U>
+    operator TemporaryRef<U>() { return TemporaryRef<U>(ptr); }
+
     /** 
      * WARNING for ease of use, passing a reference will release/clear out ptr!
      * We null out the ptr before returning its address so people passing byref
@@ -96,67 +109,71 @@
      */
     T** operator&()
     {
-    if (mPtr) {
-        mPtr->Release();
-        mPtr = NULL;
-    }
-    return &mPtr;
+       if (ptr) {
+           ptr->Release();
+           ptr = NULL;
+       }
+       return &ptr;
     }
 
-    T* operator->()
-    {
-    return mPtr;
+private:
+    void assign(T* t) {
+        unref(ptr);
+        ptr = t;
     }
 
-    T* operator->() const
-    {
-    return mPtr;
-    }
+    T* ptr;
 
-    operator bool()
-    {
-    return (mPtr ? true : false);
+    static inline T* ref(T* t) {
+        if (t) {
+            t->AddRef();
+        }
+        return t;
     }
 
-    operator T*() const
-    {
-    return mPtr;
+    static inline void unref(T* t) {
+        if (t) {
+            t->Release();
+        }
     }
+};
 
-    template <class newType>
-    operator RefPtr<newType>()
-    {
-    RefPtr<newType> newPtr;
-    newPtr = mPtr;
-    return newPtr;
-    }
+/**
+ * TemporaryRef<T> represents an object that holds a temporary
+ * reference to a T.  TemporaryRef objects can't be manually ref'd or
+ * unref'd (being temporaries, not lvalues), so can only relinquish
+ * references to other objects, or unref on destruction.
+ */
+template<typename T>
+class TemporaryRef
+{
+    // To allow it to construct TemporaryRef from a bare T*
+    friend class RefPtr<T>;
 
-    T* get() const
-    {
-    return mPtr;
-    }
+    typedef typename RefPtr<T>::dontRef dontRef;
 
-    T* forget()
-    {
-    T* ptr = mPtr;
-    mPtr = NULL;
-    return ptr;
+public:
+    TemporaryRef(T* t) : ptr(RefPtr<T>::ref(t)) {}
+    TemporaryRef(const TemporaryRef& o) : ptr(o.drop()) {}
+
+    template<typename U>
+    TemporaryRef(const TemporaryRef<U>& o) : ptr(o.drop()) {}
+
+    ~TemporaryRef() { RefPtr<T>::unref(ptr); }
+
+    T* drop() const {
+        T* tmp = ptr;
+        ptr = 0;
+        return tmp;
     }
 
 private:
-    void assignPtr(T* aPtr)
-    {
-    T *oldPtr = mPtr;
-    mPtr = aPtr;
-    if (mPtr) {
-        mPtr->AddRef();
-    }
-    if (oldPtr) {
-        oldPtr->Release();
-    }
-    }
+    TemporaryRef(T* t, const dontRef&) : ptr(t) {}
+
+    mutable T* ptr;
 
-    T *mPtr;
+    TemporaryRef();
+    TemporaryRef& operator=(const TemporaryRef&);
 };
 
 #endif
